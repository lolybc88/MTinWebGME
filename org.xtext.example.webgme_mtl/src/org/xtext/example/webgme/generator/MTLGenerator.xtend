/*
 * generated by Xtext
 */
package org.xtext.example.webgme.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.xtext.example.webgme.mTL.*
import org.xtext.example.webgme.mTL.ComplexExpression
import org.eclipse.emf.common.util.EList
import org.xtext.example.webgme.mTL.Navigation

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class MTLGenerator implements IGenerator {
	
	int i
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		
            fsa.generateFile(
            	resource.URI.toString.substring(resource.URI.toString.lastIndexOf("/"), resource.URI.toString.lastIndexOf("."))+".js",
            	resource.compile)
		
	}
	
	def compile(Resource resource) '''
    
    «writeIntro()»
    
    modeltransformation.prototype.main = function (callback) {

        var self = this,
        	«FOR outPattern : resource.allContents.toIterable.filter(OutPattern)»
        	«outPattern.varName»,
        	«ENDFOR»
        	trgModelNode,
        	elem;
        
        self.extractDataModel()
            .then(function () {

                /* Setting the pointer to the trgModel node where the target model will be stored */
                trgModelNode = self.activeNode;
                
                «writeFirstPhase(resource)»
                
                «writeSecondPhase(resource)»

            })
            .then(function () {
                return self.save('class2relational updated model.');
            })
            .then(function () {
                self.result.setSuccess(true);
                callback(null, self.result);
            })

    };
    
    «writeMTMethods()»

    return modeltransformation;
});
'''

	
	def writeIntro() '''
define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    var modeltransformation = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
        this.pathToNode = {};
        this.trgElements = {};
        this.traces = {
            trace: []
        };
    };
    
    modeltransformation.metadata = pluginMetadata;
    modeltransformation.prototype = Object.create(PluginBase.prototype);
    modeltransformation.prototype.constructor = modeltransformation;
	'''
	
	def writeFirstPhase(Resource resource) '''
				/* First phase - Element creation */
                for (var key in self.pathToNode){
                    elem = self.pathToNode[key];
                
                    «FOR rule : resource.allContents.toIterable.filter(Rule)»
						«IF rule.name != null»
	
«««					«FOR inpattern : rule.inPatterns»
					«IF rule.inPatterns!=null»
                    if (self.isMetaTypeOf(elem, self.META['«rule.inPatterns.get(0).className»']) === true) {
                     	var «rule.inPatterns.get(0).inElem» = elem;
                    «ENDIF» 	
                     	«IF rule.filter != null»
                     	«compileComplexExpression(rule.filter.expr, 0, "filter")»
                     	if (filter){
                     	«ENDIF»
                     	
	                     	self.logger.error('Rule: Class 2 Table');
	                     	/* Elements creation */
	                     «FOR i:0..< rule.outPatterns.size»
	                     
	                     var trace«i» = {
                            srcElementIds: [],
                            trgElementId: '',
                            ruleName: '',
                            position: 0
                        }; // Missing the rest of the traces
	                     
	        				«rule.outPatterns.get(i).varName» = self.core.createNode({
	                            parent: trgModelNode,
	                            base: self.META.«rule.outPatterns.get(i).className»
	                        });
	                        self.core.setAttribute(«rule.outPatterns.get(i).varName», 'name', '«rule.outPatterns.get(i).className»');
	                        «FOR assig : rule.outPatterns.get(i).assg»
	                        	//--
		                        «IF assig.attribute != null»
		                        «compileComplexExpression(assig.expr, 0, 'exp')»
		                        self.core.setAttribute(«rule.outPatterns.get(i).varName», '«assig.attribute»', exp);
		                        //--
		                        «ENDIF»
	                        «ENDFOR»
	                        self.core.setRegistry(«rule.outPatterns.get(i).varName», 'position', {x: 50, y: 100});
	                        self.trgElements[self.core.getPath(«rule.outPatterns.get(i).varName»)] = «rule.outPatterns.get(i).varName»;
	                        trace«i».srcElementIds.push(key);
	                        trace«i».trgElementId = self.core.getPath(«rule.outPatterns.get(i).varName»);
	                        trace«i».ruleName = '«rule.name»';
	                        trace«i».position = «i+1»;
	                        self.traces[trace«i».srcElementIds + '-' + trace«i».position] = trace«i»;
        				«ENDFOR»;
                     	}
                     	«IF rule.filter != null»
                     	}
				        «ENDIF»
				        
				        «ENDIF»
				      	«ENDFOR»
                }
                self.logger.error('First phase finished. Starting second phase');
	'''
	
	def writeSecondPhase(Resource resource) '''
				/* Second phase - Association creation */
                for (var key in self.pathToNode){
                    elem = self.pathToNode[key];
                
					«FOR rule : resource.allContents.toIterable.filter(Rule)»
						«IF rule.name != null»
	
«««					«FOR inpattern : rule.inPatterns»
					«IF rule.inPatterns!=null»
                    if (self.isMetaTypeOf(elem, self.META['«rule.inPatterns.get(0).className»']) === true) {
                     	var «rule.inPatterns.get(0).inElem» = elem;
                    «ENDIF» 	
                     	«IF rule.filter != null»
                     	«compileComplexExpression(rule.filter.expr, 0, "filter")»
                     	if (filter){
                     	«ENDIF»
                     	
	                     	self.logger.error('Rule: Class 2 Table');
	                     	/* Elements creation */
	                     «FOR i:0..< rule.outPatterns.size»
	                     
	                        «FOR assig : rule.outPatterns.get(i).assg»
	                        	
	                        	
	                        	
		                        «IF assig.relationship != null»
		                        //--
		                        «rule.outPatterns.get(i).varName» = self.resolve(elem, «i+1»);
		                        «compileComplexExpression(assig.expr, 0, "exp")»
		                        «IF assig.relationship.children != null»
		                        if ( exp instanceof Array ) {
		                        	self.addChildren(«rule.outPatterns.get(i).varName», exp);
		                        } else {
		                        	self.addChild(«rule.outPatterns.get(i).varName», exp);
		                        }
		                        «ENDIF»
		                        «IF assig.relationship.parent != null»
		                        self.setParent(«rule.outPatterns.get(i).varName», exp);
		                        «ENDIF»
		                        «IF assig.relationship.name != null»
		                        self.core.setPointer(«rule.outPatterns.get(i).varName», 'key', exp);
		                        «ENDIF»
		                        //--
		                        «ENDIF»
	                        «ENDFOR»
        				«ENDFOR»
                     	}
                     	«IF rule.filter != null»
                     	}
				        «ENDIF»
				        
				        «ENDIF»
				      	«ENDFOR»
                }		          
                self.logger.error('done');
	'''
		
	def compileComplexExpression(ComplexExpression expression, int nestingLevel, String varName) '''
		«IF expression.left != null»
			«compileSimpleExpression(expression.left, nestingLevel, "left")»
		«ENDIF»
		«IF expression.right != null && expression.right.size>0 && expression.infixOp != null && expression.infixOp.size>0»
			«FOR i:0..< expression.right.size»
				«IF i>0»
				var left = «varName»;
				«ENDIF»
				«compileSimpleExpression(expression.right.get(i), nestingLevel, "right")»
				«compileInfixOp(expression.infixOp.get(i), varName)»
			«ENDFOR»
		«ELSE»
			var «varName» = left;
		«ENDIF»
		«IF expression.left != null && expression.prefixNot != null»
			var «varName» = !«varName»;
		«ENDIF»
	'''
	
	def compileInfixOp(String infixOp, String varName) '''
		var «varName» = left	«IF infixOp.equals('=')»==«ENDIF»
		«IF infixOp.equals('!=')»!=«ENDIF»
		«IF infixOp.equals('>')»>«ENDIF»
		«IF infixOp.equals('<')»<«ENDIF»
		«IF infixOp.equals('>=')»>=«ENDIF»
		«IF infixOp.equals('<=')»<=«ENDIF»
		«IF infixOp.equals('+')»+«ENDIF»
		«IF infixOp.equals('-')»-«ENDIF»
		«IF infixOp.equals('*')»*«ENDIF»
		«IF infixOp.equals('/')»/«ENDIF»
		«IF infixOp.equals('and')»&&«ENDIF»
		«IF infixOp.equals('or')»||«ENDIF»right;
	'''
	
	def compileSimpleExpression(SimpleExpression expression, int nestingLevel, String varName){
			if (expression._string != null){
				'''var «varName» = '«expression._string»';'''
				
			} else if (expression._double != null){
				'''var «varName» = «expression._double»;'''
				
			} else if (expression._boolean != null){
				'''var «varName» = «expression._boolean»;'''
				
			} else if (expression.isNull != null){
				'''var «varName» = null;'''
				
			} else if (expression.navigation != null){
				if (expression.navigation.navigation!=null && expression.navigation.navigation.size!=0){
					'''«compileNavigation(expression.navigation.attr, expression.navigation.navigation, nestingLevel, varName)»'''	
				} else {
					'''var «varName» = «expression.navigation.attr»;'''
				}
			} else if (expression.ifSentence != null){
				'''«compileComplexExpression(expression.ifSentence.cond, nestingLevel, "condition")»
				if (condition){
					«compileComplexExpression(expression.ifSentence.body, nestingLevel, varName)»
				} else {
					«compileComplexExpression(expression.ifSentence.elsebody, nestingLevel, varName)»
				}'''
			} else if (expression.colectionType!=null){
			
			} else if (expression.resolve != null){
				'''«compileComplexExpression(expression.resolve.exp, nestingLevel, varName)»
				var «varName» = self.resolve(«varName», «expression.resolve.position»);'''
			} else { // (expression._integer != null){
				'''var «varName» = «expression._integer»;'''
			} 
		}
	
	def compileNavigation(String attr, EList<Navigation> navAttr, int nestingLevel, String varName) '''
		
		«IF navAttr != null»
		«IF navAttr.get(0) != null»
		«IF (navAttr.get(0).opType1 == null || navAttr.get(0).opType1.allIns == null)»
			var nav«nestingLevel» = «attr»;
		«ENDIF»
		«ENDIF»
		«ENDIF»
		
		«FOR i:0..< navAttr.size»
			«IF navAttr.get(i).attName != null»
				var nav«nestingLevel» = self.core.getAttribute(nav«nestingLevel», '«navAttr.get(i).attName»');
			«ENDIF»
			«IF navAttr.get(i).assocRole != null»
				«IF navAttr.get(i).assocRole.name != null»
					var nav«nestingLevel» = self.navigateToNode(nav«nestingLevel», '«navAttr.get(i).assocRole.name»');
				«ENDIF»
				«IF navAttr.get(i).assocRole.children != null»
					var nav«nestingLevel» = self.getChildren(nav«nestingLevel»);
				«ENDIF»
				«IF navAttr.get(i).assocRole.parent != null»
					var nav«nestingLevel» = self.core.getParent(nav«nestingLevel»);
				«ENDIF»
			«ENDIF»
			«IF navAttr.get(i).opType1 != null»
				«IF navAttr.get(i).opType1.allIns != null»
					var nav«nestingLevel» = [];
					for (var k in self.pathToNode){
	                    var ele = self.pathToNode[k];
	                    if (self.isMetaTypeOf(ele, self.META['«attr»']) === true) {
	                    	nav«nestingLevel».push(ele);
	                    }
	                }
				«ENDIF»
				«IF navAttr.get(i).opType1.isTypeOf != null»
					var nav«nestingLevel» = self.isMetaTypeOf(«attr», self.META['«navAttr.get(i).opType1.isTypeOf.className»']) === true; 
				«ENDIF»
				«IF navAttr.get(i).opType1.getToString() != null»
					var nav«nestingLevel» = nav«nestingLevel».toString(); 
				«ENDIF»
				«IF navAttr.get(i).opType1.concatenate != null»
					var nav«nestingLevel» = nav«nestingLevel» + '«navAttr.get(i).opType1.concatenate.s»'; 
				«ENDIF»
			«ENDIF»
			«IF navAttr.get(i).opType2 != null»
				«IF navAttr.get(i).opType2.first != null»
					var nav«nestingLevel» = nav«nestingLevel»[0];
				«ENDIF»
				«IF navAttr.get(i).opType2.size != null»
					var nav«nestingLevel» = nav«nestingLevel».length;
				«ENDIF»
				«IF navAttr.get(i).opType2.last != null»
					var nav«nestingLevel» = nav[nav«nestingLevel».length-1];
				«ENDIF»
				«IF navAttr.get(i).opType2.indexOf != null»
					var nav«nestingLevel» = nav«nestingLevel»[«navAttr.get(i).opType2.indexOf.index»];
				«ENDIF»
				«IF navAttr.get(i).opType2.union != null»
					«compileComplexExpression(navAttr.get(i).opType2.union.exp, nestingLevel+1, 'exp')»
					var nav«nestingLevel» = new Set(nav«nestingLevel»);
	                for (var k in exp){
	                    if (!nav«nestingLevel».has(k)){
	                       nav«nestingLevel».add(k);
	                    }
	                }
				«ENDIF»
				«IF navAttr.get(i).opType2.intersection != null»
					«compileComplexExpression(navAttr.get(i).opType2.intersection.exp, nestingLevel+1, 'exp')»
					var intersect = new Set();
	                for (var k in exp){
	                    if (nav«nestingLevel».has(k)){
	                       intersect.add(k);
	                    }
	                }
	                var nav«nestingLevel» = intersect;
				«ENDIF»
«««				«IF navAttr.get(i).opType2.isUndefined != null»
«««					var undefined ...
«««	                
«««				«ENDIF»
				«IF navAttr.get(i).opType2.forall != null»
					var forall = true;
                    var j = 0;
                    while (forall && j<nav«nestingLevel».length){
                    	var «navAttr.get(i).opType2.forall.^var» = nav«nestingLevel»[j];
						«compileComplexExpression(navAttr.get(i).opType2.forall.exp, nestingLevel+1, 'exp')»
						forall = exp;
                        j++;
                    }
					var nav«nestingLevel» = forall;
				«ENDIF»
				«IF navAttr.get(i).opType2.exists != null»
					var found = false;
                    var j = 0;
                    while (!found && j<nav«nestingLevel».length){
                    	var «navAttr.get(i).opType2.exists.^var» = nav«nestingLevel»[j];
						«compileComplexExpression(navAttr.get(i).opType2.exists.exp, nestingLevel+1, 'exp')»
						found = exp;
                        j++;
                    }
					var nav«nestingLevel» = found;
				«ENDIF»
				«IF navAttr.get(i).opType2.select != null»
					var select = [];
					for (var i«navAttr.get(i).opType2.select.^var» = 0; i«navAttr.get(i).opType2.select.^var» < nav«nestingLevel».length; i«navAttr.get(i).opType2.select.^var» += 1) {
						var «navAttr.get(i).opType2.select.^var» = nav«nestingLevel»[i«navAttr.get(i).opType2.select.^var»];
						«compileComplexExpression(navAttr.get(i).opType2.select.exp, nestingLevel+1, 'exp')»
						if (exp){
							select.push(«navAttr.get(i).opType2.select.^var»);
						}
					}
					var nav«nestingLevel» = select;
				«ENDIF»
				«IF navAttr.get(i).opType2.collect != null»
					var collect = [];
					for (var i«navAttr.get(i).opType2.collect.^var» = 0; i«navAttr.get(i).opType2.collect.^var» < nav«nestingLevel».length; i«navAttr.get(i).opType2.collect.^var» += 1) {
						var «navAttr.get(i).opType2.collect.^var» = nav«nestingLevel»[i«navAttr.get(i).opType2.collect.^var»];
						«compileComplexExpression(navAttr.get(i).opType2.collect.exp, nestingLevel+1, 'exp')»
						collect.push(exp);
					}
					var nav«nestingLevel» = collect;
				«ENDIF»
			«ENDIF»
		«ENDFOR»
		var «varName» = nav«nestingLevel»;
	'''
	
	def writeMTMethods() '''
	modeltransformation.prototype.addChild = function (node, childNode, callback) {
        /** Given an source element, this method returns the element created from it in the position specified in the second parameter */
        var self = this;
        self.core.moveNode(childNode, node);
    }
    
    modeltransformation.prototype.addChildren = function (node, childNodes, callback) {
        /** Given an source element, this method returns the element created from it in the position specified in the second parameter */
        var self = this;
        for (var ii = 0; ii < childNodes.length; ii += 1) {
            self.core.moveNode(childNodes[ii], node);
        }
    }

    modeltransformation.prototype.setParent = function (node, parentNode, callback) {
        /** Given an source element, this method returns the element created from it in the position specified in the second parameter */
        var self = this;
        self.core.moveNode(node, parentNode);
    }

    modeltransformation.prototype.resolve = function (sourceNode, position, callback) {
        /** Given an source element, this method returns the element created from it in the position specified in the second parameter */
        var self = this;
        return self.trgElements[self.traces[self.core.getPath(sourceNode) + '-' + position].trgElementId];

    }
    modeltransformation.prototype.navigateToNode = function (sourceNode, pointerName, callback) {
        var self = this,
            pointerPath,
            targetNode;

        pointerPath = self.core.getPointerPath(sourceNode, pointerName);
        targetNode = self.pathToNode[pointerPath];

        return targetNode;
    }

    modeltransformation.prototype.getChildrenPaths = function (node, callback) {
        var self = this,
            nodesPath;

        nodesPath = this.core.getChildrenPaths(node);
        return nodesPath;
    }

    modeltransformation.prototype.getChildren = function (node, callback) {
        var self = this,
            childrenPath,
            i,
            children = [];

        childrenPath = this.core.getChildrenPaths(node);
        for (i = 0; i < childrenPath.length; i += 1) {
            children.push(self.pathToNode[childrenPath[i]]);
        }
        return children;
    }

    modeltransformation.prototype.extractDataModel = function (callback) {
        var self = this;

        // In order to avoid multiple iterative asynchronous 'load' calls we pre-load all the nodes in the family
        // and build up a local hash-map where the keys are the path/id of the nodes and the value the (nodes) objects
        // themselves. The info is stored in self.pathToNode
        return this.core.loadSubTree(self.activeNode)
            .then(function (nodes) {

                var i,
                    childNode,
                    childName,
                    childrenPaths;

                for (i = 0; i < nodes.length; i += 1) {
                    // For each node in the subtree we get the path and use it for the index of the hash-map, where
                    // values are the actual node.
                    self.pathToNode[self.core.getPath(nodes[i])] = nodes[i];
                }

                return null;
            })
            .nodeify(callback);
    };
	'''

}
